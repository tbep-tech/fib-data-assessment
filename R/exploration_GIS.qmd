---
title: "Playing around with GIS layer files"
format: html
embed-resources: true
---

```{r}
library(sf)
library(ggplot2)
```

Following this tutorial: https://jsta.github.io/glatos-spatial_workshop_materials/01-vector-open-shapefile-in-r/  
and this one:
https://jsta.github.io/glatos-spatial_workshop_materials/02-vector-shapefile-attributes-in-r/  
and: 
https://jsta.github.io/glatos-spatial_workshop_materials/03-vector-csv-to-shapefile-in-r/index.html  

# read in shapefile

```{r}
bay_segs <- st_read(here::here("GIS", "TBEP-Bay_Segments.shp"))
```

# explore metadata

```{r}
st_geometry_type(bay_segs)  # polygon
st_crs(bay_segs)            # NAD83 datum
st_bbox(bay_segs)           # bounding box

bay_segs                    # all metadata attributes

# can use all the normal data exploration tools too
names(bay_segs)
dplyr::glimpse(bay_segs)
dim(bay_segs)
head(bay_segs)
```


Can filter using dplyr if we only want to see or use a portion of it.  

```{r}
TB <- bay_segs |> 
    dplyr::filter(stringr::str_detect(BAY_SEG, "Tampa Bay"))
TB
```


# plot  

don't need to convert vector data before using ggplot (do have to convert raster data)  

```{r}
ggplot(bay_segs) +
    geom_sf(size = 1.5, 
            color = "black", 
            fill = "cadetblue3") +
    coord_sf() +       # ensures all layers use common CRS
    labs(title = "Bay Segments of Tampa Bay",
         caption = "Source: TBEP")


ggplot(bay_segs) +
    geom_sf(size = 1.5, 
            color = "black", 
            fill = "cadetblue3") +
    geom_sf_label(aes(label = BAY_SEG)) +
    coord_sf() +       # ensures all layers use common CRS
    labs(title = "Bay Segments of Tampa Bay",
         caption = "Source: TBEP")


ggplot(bay_segs) +
    geom_sf(aes(fill = BAY_SEG),
            size = 1.5, 
            color = "black") +
    coord_sf() +       # ensures all layers use common CRS
    labs(title = "Bay Segments of Tampa Bay",
         caption = "Source: TBEP")


```

# create some coordinates  

```{r}
dummy_coords <- data.frame(ID = c(1, 2),
                           lat = c(27.60, 27.80),
                           long = c(-82.1, -82.5))
```

# plot them with the bay segments  

ggplot is smart  

```{r}
ggplot() +
    geom_sf(data = bay_segs,
            aes(fill = BAY_SEG),
            size = 1.5, 
            color = "black") +
    geom_point(data = dummy_coords,
               aes(x = long, y = lat),
               size = 5,
               color = "red3") +
    coord_sf()
```


# turn lat/longs into a sf object  

```{r}
dummy_locations <- st_as_sf(dummy_coords,
                            coords = c("long", "lat"),
                            crs = "NAD83")

# or could have pulled the crs type from the object we have already, if it's the same  
dummy_crs <- st_crs(bay_segs)
# actually that does give more info

dummy_locations <- st_as_sf(dummy_coords, 
                            coords = c("long", "lat"),
                            crs = dummy_crs)

dummy_locations2 <- st_as_sf(dummy_coords, 
                            coords = c("long", "lat"),
                            crs = st_crs(4326))
# could also have used crs = st_crs("WGS84")

```

Apparently the "plain latitude-longitude coordinate system (using the WGS84 datum)" is EPSG4326. Fortunately the points on the map seem to be in the same place (way below, at the end of my mapview explorations)    

Thanks to the tmap book for this education: https://r-tmap.github.io/tmap-book/geodata.html  

tmap also lets you present both static and interactive maps (I think mapview does too)  

Can use `st_transform()` to convert between projections  

# ggplot2  

```{r}
ggplot() +
    geom_sf(data = bay_segs,
            aes(fill = BAY_SEG),
            size = 1.5, 
            color = "black") +
    geom_sf(data = dummy_locations,
            size = 5,
            color = "red3") +
    coord_sf()
```

Can use `st_write()` to write out a shapefile  

# basic plotting in sf  

from the vignettes: https://r-spatial.github.io/sf/articles/sf5.html#plot-methods-for-sf-and-sfc-objects  

```{r}
plot(bay_segs)   # plots all attributes
plot(st_geometry(bay_segs))  # plots shape only

# add centroids
plot(st_geometry(st_centroid(bay_segs)), pch = 3, col = "red", add = TRUE)



plot(st_geometry(bay_segs), col = sf.colors(10, categorical = TRUE) , axes = TRUE, border = "black")  
plot(st_geometry(st_centroid(bay_segs)), pch = 3, col = "red", add = TRUE)
```

# interactive in html docs  

mapview, apparently uses leaflet? I would have gone to leaflet directly. Link to mapview: https://r-spatial.github.io/mapview/  

```{r}
library(mapview)
```

```{r}
mapview(bay_segs)

# don't show as many attributes:
mapview(bay_segs, zcol = c("BAY_SEG"))

# add a couple different layers:
mapview(list(bay_segs, dummy_locations),
        layer.name = c("Bay Segments", "Dummy Points"))

# or:
mapview(bay_segs, zcol = "BAY_SEG") +
    dummy_locations

# or:
mapview(bay_segs, zcol = "BAY_SEG") +
    mapview(dummy_locations)

# or:
mapview(list(bay_segs, dummy_locations),
        layer.name = c("Bay Segments", "Dummy Points"),
        zcol = list("BAY_SEG", NULL),
        legend = list(TRUE, FALSE),
        col.regions = c(mapViewPalette("mapviewVectorColors"), "red"))



```

Can color points based on one of the attributes, which would be useful to show which indicators are measured at any given station!!!  

```{r}
mapview(list(bay_segs, dummy_locations, dummy_locations2),
        layer.name = c("Bay Segments", "Dummy Points", "Dummy WGS pts"),
        zcol = list("BAY_SEG", NULL, NULL),
        legend = list(TRUE, FALSE, FALSE),
        col.regions = c(mapViewPalette("mapviewVectorColors"), "red", "blue"))
```


# leaflet  

```{r}
library(leaflet)
```

```{r}
leaflet() |> 
    addTiles() |> 
    addPolygons(data = bay_segs) |> 
    addCircleMarkers(data = dummy_locations,
                     color = "red")
```

So far I have to muscle a lot more using leaflet than I did with mapview.  



# originally in exploration part 2











```{r}
map_colors <- viridis::viridis(3)

mapview(list(bay_segs, drainage_basins, watersheds),
        col.regions = map_colors)
```

TBEP Bay Segments is the same as 'Tampa Bay Watersheds' but with one less watershed: "Coastal Pinellas/Anclote Watershed".  



## Map  

```{r}
map_colors <- viridis::viridis(2)

point_colorsFIB <- RColorBrewer::brewer.pal(length(unique(fib_toMap$`FIB Combo`)), "Set1")
point_colorsOrg <- viridis::viridis(length(unique(fib_toMap$OrgName)))

# alternately:
# point_colors <- viridis::viridis(length(unique(fib_toMap$`FIB Combo`)))

mapview(list(drainage_basins, watersheds, fib_toMap, fib_toMap),
        layer.name = c("Drainage Basins", "Watersheds", "Params at points", "Orgs measuring points"),
        zcol = list(NULL, NULL, "FIB Combo", "OrgName"),
        col.regions = list(map_colors[1],
                           map_colors[2],
                           point_colorsFIB,
                           point_colorsOrg))
```

What I'd really like to do is filter the points to only within the watersheds of interest. Same with the WBID layer.  

Would it be useful to have each type of fecal indicator be a different layer? Or could just have colors/shapes for the individual types, and their combinations? 

```{r}
library(tmap)
```

```{r}

map1 <- tm_shape(watersheds) + tm_polygons() +
    tm_basemap(server = "OpenTopoMap") +
    tm_shape(fib_toMap) + tm_symbols(shape = 18, col = "blue", size = 0.5) +
    tm_shape(fib_toMap) + tm_symbols(shape = 0, col = "blue", size = 0.5) +
    tm_shape(fib_toMap) + tm_symbols(shape = 3, col = "red", size = 0.5)
```

```{r}
map1
```

```{r}
tmap_mode("view")
map1
```

gah only circles or icons are supported in interactive mode  

also something is wrong with the watersheds polygon "The shape watersheds is invalid (after reprojection). See sf::st_is_valid"  


**could do this** - side-by-side plots, switching between two variables?  https://www.paulamoraga.com/book-spatial/making-maps-with-r.html#side-by-side-plots-with-mapview  


```{r}
col_vec <- c("Fecal Coliform" = "navy",
             "Enterococcus" = "blue",
             "E. coli" = "red")
shape_vec <- c("Fecal Coliform" = 18,
             "Enterococcus" = 0,
             "E. coli" = 3)

map2 <- ggplot() +
    geom_sf(data = watersheds, aes(fill = WATERSHEDN), alpha = 0.5) +
    geom_sf(data = fib_feccol, aes(col = "Fecal Coliform", shape = "Fecal Coliform")) +
    geom_sf(data = fib_entero, aes(col = "Enterococcus", shape = "Enterococcus")) +
    geom_sf(data = fib_ecoli, aes(col = "E. coli", shape = "E. coli")) +
    scale_color_manual(values = col_vec) +
    scale_shape_manual(values = shape_vec)
```

```{r}
library(plotly)
```

```{r}
ggplotly(map2)
```




